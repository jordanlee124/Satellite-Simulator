Throughout the making of this assignment, decisions had to be made with my miminal expereince in regards to the java language and OOP design principles.
As I began to work through task 1, the first hurdle I was faced with was the getInfo method. This method should return information of an object with 
provided id, whether it is a satellite or a device. I had 2 loops that looped through a device list and satellite list I had. This would've violated the 
design principle of DRY due to the repetion of code. But, with the introduction of the Entity class, which is the superclass of Device and Satellite, I
was able to condense it into one loop that iterated through a list of all the entities that existed in the current BlackoutController instance.

Another decision I made was to not create separate classes for HandheldDevice, LaptopDevice and DesktopDevice because I believed that there was no point because
it would cause me to repeat code (e.g. getters and setters). I wondered, why not just set it all in the Entity class? I'm pretty sure that this was the wrong thing
to do. I am still not sure, but I believe it would have been better for me to set maxRange and supports in the respective specfic classes. Due to the fact that I set these unique values in Entity, the HandheldDevice, LaptopDevice, DesktopDevice, StandardSatellite and ShrinkingSatellite classes are almost stripped of their relevance. To fix this issue,
I would make Entity an abstract class that is extended by Device and Satellite, and return the instancing to the Device and Satellite classes. I would also 
set the unique variables in their respective classes (because this is probably the right thing to do). 

To impliment task 3, I would create 2 new subclasses: ElephantSatellite and CloudStorageDevice. To implement ElephantSatellite, I would change the hasTransferCompleted to a string that could take the values "true", "false", "transient". Or I would have to check if the entity the file in question resides in, is an instanceof ElephantSatellite. If this is true and hasTransferCompleted is false, the file will have another boolean variable "transient" and this would be set to true. This will stop the file from being deleted and it will also stop the file from beint uploaded while the satellite is out of range of the other entity. The 'However, it's not going to hold it forever; if at any point memory becomes an issue (i.e. there is not enough space for new transfers) it will delete transient files (that aren't currentlyâ€‹ transferring) to make room' issue would be handled in the sendFile method before any exceptions are thrown. This will ensure that the satellite has a chance to delete transient files before before checking for storage exceptions. Not too sure how I will implement CloudStorageDevice.